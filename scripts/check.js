// Generated by CoffeeScript 1.9.2
(function() {
  var has_all_structures,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  has_all_structures = function(structures) {
    var i, key, len, result, structure, value;
    for (i = 0, len = structures.length; i < len; i++) {
      structure = structures[i];
      if (!structure.has) {
        return false;
      }
      for (key in structure) {
        value = structure[key];
        if (key === 'type') {
          continue;
        }
        result = has_all_structures(structure[key]);
        if (result === false) {
          return false;
        }
      }
    }
    return true;
  };

  window.check_code = function(string, arg) {
    var banned, banned_found, code_structure, i, len, node, parsed, ref, required, required_found, required_missing, structure_has, type, visit_node;
    required = arg.required, banned = arg.banned, code_structure = arg.code_structure;
    required || (required = []);
    banned || (banned = []);
    structure_has = JSON.parse(code_structure);
    parsed = esprima.parse(string);
    required_found = [];
    banned_found = [];
    visit_node = function(node, structure_pointers) {
      var child, found_structures, i, j, key, len, len1, pointer, ref, ref1, ref2, ref3, structure, visit_child;
      if (node === null) {
        return;
      }
      if ((ref = node.type, indexOf.call(banned, ref) >= 0) && (ref1 = node.type, indexOf.call(banned_found, ref1) < 0)) {
        banned_found.push(node.type);
      }
      if ((ref2 = node.type, indexOf.call(required, ref2) >= 0) && (ref3 = node.type, indexOf.call(required_found, ref3) < 0)) {
        required_found.push(node.type);
      }
      found_structures = [];
      for (i = 0, len = structure_pointers.length; i < len; i++) {
        pointer = structure_pointers[i];
        for (j = 0, len1 = pointer.length; j < len1; j++) {
          structure = pointer[j];
          if (node.type === structure.type) {
            structure.has = true;
            found_structures.push(structure);
          }
        }
      }
      visit_child = function(node, key) {
        var child, child_node, child_structure_pointers, k, l, len2, len3;
        child_structure_pointers = [];
        child_structure_pointers = child_structure_pointers.concat(structure_pointers);
        for (k = 0, len2 = found_structures.length; k < len2; k++) {
          structure = found_structures[k];
          if (key in structure) {
            child_structure_pointers.push(structure[key]);
          }
        }
        child = node[key];
        if (child instanceof Array) {
          for (l = 0, len3 = child.length; l < len3; l++) {
            child_node = child[l];
            visit_node(child_node, child_structure_pointers);
          }
        } else if (typeof (child != null ? child.type : void 0) === 'string') {
          visit_node(child, child_structure_pointers);
        }
        return void 0;
      };
      for (key in node) {
        child = node[key];
        if (child instanceof Array || typeof (child != null ? child.type : void 0) === 'string') {
          visit_child(node, key);
        }
      }
      return void 0;
    };
    ref = parsed.body;
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      visit_node(node, [structure_has]);
    }
    required_missing = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = required.length; j < len1; j++) {
        type = required[j];
        if (indexOf.call(required_found, type) < 0) {
          results.push(type);
        }
      }
      return results;
    })();
    return {
      required_missing: required_missing,
      banned_found: banned_found,
      structure_has: structure_has,
      structure_match: has_all_structures(structure_has)
    };
  };

}).call(this);
